# Cursor Rules for Assety

## 🎯 プロジェクトの位置づけ

**主目的**: 価値ある家計管理アプリケーションの構築
**副次的効果**: 現代的なWeb技術の実践的学習

## 🏗️ アーキテクチャ・技術スタック

### フロントエンド
- Next.js 15 (App Router)
- React 18 + TypeScript
- Tailwind CSS
- Redux Toolkit

### バックエンド
- GraphQL (Apollo Server)
- Prisma ORM
- PostgreSQL

### インフラ
- AWS (RDS, CloudFront)
- Vercel (Frontend)

## 📋 コード生成・支援の原則

### 1. ユーザー価値を最優先
- 機能実装時は常にユーザーの課題解決を意識
- UIは直感的で使いやすさを重視
- パフォーマンスとアクセシビリティを考慮

### 2. 学習要素の組み込み
- 実装時に技術的な学習ポイントをコメントで説明
- ベストプラクティスを適用し、その理由を明記
- 代替実装方法があれば選択理由を説明

### 3. 型安全性の徹底
- TypeScriptの型定義を厳密に
- Prismaスキーマとの整合性を保つ
- GraphQLスキーマとの型連携

### 4. テスタビリティ
- テストしやすい設計を心がける
- 適切な単体テストを提案
- E2Eテストシナリオを考慮

## 🎨 コーディングスタイル

### ファイル構造
```
apps/web/src/
├── app/                    # Next.js App Router
├── components/             # Reactコンポーネント
│   ├── ui/                # 基本UIコンポーネント
│   ├── features/          # 機能別コンポーネント
│   └── layout/            # レイアウトコンポーネント
├── lib/                   # ユーティリティ・設定
├── hooks/                 # カスタムフック
├── store/                 # Redux store
└── types/                 # 型定義
```

### 命名規則
- **コンポーネント**: PascalCase (`TransactionForm`)
- **ファイル**: kebab-case (`transaction-form.tsx`)
- **関数・変数**: camelCase (`calculateTotal`)
- **定数**: UPPER_SNAKE_CASE (`API_ENDPOINTS`)

### コンポーネント設計
- 単一責任の原則
- Props の型定義を明確に
- デフォルトエクスポートよりnamed exportを推奨
- コンポーネントの責務をコメントで明記

## 📝 コメント・ドキュメント

### 学習ポイントの記載
```typescript
/**
 * 月次支出チャートコンポーネント
 * 
 * ユーザー価値: 支出傾向を視覚的に把握できる
 * 学習ポイント: 
 * - Recharts でのレスポンシブチャート実装
 * - TypeScript での Chart.js 型定義
 * - useMemo を使ったパフォーマンス最適化
 */
```

### 技術的判断の理由
```typescript
// Redux Toolkit を選択した理由:
// - Boilerplate の削減
// - Immer による immutable 更新
// - RTK Query での API状態管理
// 学習効果: 現代的な状態管理パターンの習得
```

## 🔧 実装ガイドライン

### 1. API設計
- GraphQL スキーマファーストアプローチ
- 型安全なクエリ・ミューテーション
- エラーハンドリングの統一

### 2. 状態管理
- Redux Toolkit でのスライス設計
- 非同期処理は RTK Query
- ローカル状態は useState/useReducer

### 3. スタイリング
- Tailwind CSS のユーティリティクラス
- コンポーネント固有スタイルは CSS Modules
- レスポンシブデザインの徹底

### 4. パフォーマンス
- React.memo での不要な再レンダリング防止
- useMemo/useCallback の適切な使用
- 画像最適化（Next.js Image コンポーネント）

## 🧪 テスト戦略

### 単体テスト
- Jest + React Testing Library
- コンポーネントの振る舞いをテスト
- カスタムフックのテスト

### 統合テスト
- API エンドポイントのテスト
- データベース操作のテスト

### E2Eテスト
- Playwright でのユーザーシナリオ
- 主要な機能フローをカバー

## 📚 学習支援

### コード生成時の説明
- 使用した技術の選択理由
- 実装パターンの学習ポイント
- 改善可能な点や代替案

### 段階的な実装提案
1. 基本機能の実装
2. エラーハンドリングの追加
3. パフォーマンス最適化
4. テストの追加

## 🚨 注意事項

### 避けるべきパターン
- 過度に複雑な抽象化
- 学習のための学習（実用性を損なう実装）
- セキュリティを軽視した実装
- アクセシビリティを無視したUI

### 推奨パターン
- シンプルで理解しやすい実装
- 段階的な機能追加
- ユーザビリティを重視したUX
- 保守しやすいコード構造

## 💡 AI支援の活用方針

### 効果的な質問例
- "ユーザーが支出を素早く記録できるUIを実装したい"
- "TypeScript でのGraphQL型生成のベストプラクティスは？"
- "この実装の学習ポイントと改善点を教えて"

### 学習重視の依頼例
- "Redux Toolkit の使い方を学びながら実装したい"
- "Next.js App Router の特徴を活かした実装方法は？"
- "この技術選択の理由と代替案を説明して"

---

**🎯 価値あるプロダクトを作りながら、技術力も向上させていきましょう！** 